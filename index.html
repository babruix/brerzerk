<!doctype html>
<meta charset="utf-8">
<title>BERZERK</title>
<body>
<script src="pixi.min.js"></script>
<script>

// Aliases
var Rectangle = PIXI.Rectangle;
var Container = PIXI.Container;
var autoDetectRenderer = PIXI.autoDetectRenderer;
var loader = PIXI.loader;
var resources = PIXI.loader.resources;
var Sprite = PIXI.Sprite;
var Grfx = PIXI.Graphics;
PIXI.SCALE_MODES.DEFAULT = PIXI.SCALE_MODES.NEAREST;

//
var robot_sprite;
var player_sprite;
var gameState;
var timer = 0;
var num_players_remaining = 2;
var death_start_timer = -1;
var colors8 = [0xFFFFFF, 0xFFFF00, 0xFF00FF, 0x00FFFF, 0xFF0000, 0x00FF00];
var walls = [];

// https://github.com/kittykatattack/learningPixi#pixis-graphic-primitives
var renderer = autoDetectRenderer(
	1024, 768, 
	{antialias: false, transparent: false, resolution: 1}
);
document.body.appendChild(renderer.view);

var stage = new Container();
renderer.render(stage);

loader
	.add("images/robot.png")
	.add("images/robot-explode.png")
	.add("images/player.png")
	.load(setup);

function setup() {

	var robot_tex = loader.resources["images/robot.png"].texture;
	var robot_explode_tex = loader.resources["images/robot-explode.png"].texture;
	robot_sprite = new Sprite(robot_tex);
	var rect = new Rectangle(0, 0, 8, 11);
	robot_tex.frame = rect;
	robot_sprite.x = 100;
	robot_sprite.y = 100;
	robot_sprite.vx = 0;
	robot_sprite.vy = 0;
	robot_sprite.scale.set(4, 4);
	robot_sprite.ctrl_keys = ['KeyW', 'KeyD', 'KeyS', 'KeyA'];
	robot_sprite.rate = 1;
	robot_sprite.explode_tex = robot_explode_tex;
	robot_sprite.explode_tex.num_frames = 3;
	robot_sprite.tint = 0xFF0000;
	stage.addChild(robot_sprite);

	var player_tex = loader.resources["images/player.png"].texture;
	player_sprite = new Sprite(player_tex);
	var rect = new Rectangle(0, 0, 8, 17);
	player_tex.frame = rect;
	player_sprite.x = 150;
	player_sprite.y = 90;
	player_sprite.vx = 0;
	player_sprite.vy = 0;
	player_sprite.scale.set(4, 4);
	player_sprite.ctrl_keys = ['ArrowUp', 'ArrowRight', 'ArrowDown', 'ArrowLeft'];
	player_sprite.rate = 2;
	player_sprite.death_anim_duration = 80;
	player_sprite.tint = 0x00FF00;
	stage.addChild(player_sprite);

	setUpPlayerCtrlsFor(player_sprite);
	setUpPlayerCtrlsFor(robot_sprite);

	drawWalls();

	// Start the game loop
	gameState = gamePlay;
	gameLoop();
}

function gameLoop() {

	requestAnimationFrame(gameLoop);

	gameState();

	renderer.render(stage);
}


 /**
  * GAME PLAY LOOP
  **/
function gamePlay () {

	timer += 1;

	if (hitTestAny() === true) {
		death_start_timer = timer;
		if (num_players_remaining > 0) {
			  num_players_remaining -= 1;
			  gameState = playerDead;
		} else {
			  gameState = gameOver;
		}
	} else {
		player_sprite.x += player_sprite.vx;
		player_sprite.y += player_sprite.vy;

		// animate him
		player_sprite.texture.frame = getTexFrameFor(player_sprite);

		robot_sprite.x += robot_sprite.vx;
		robot_sprite.y += robot_sprite.vy;

		// animate him
		if (robot_sprite.vy > 0) {
			robot_sprite.texture.frame = new Rectangle( (Math.round(timer * 0.2) % 2) * 8 + 64, 0, 8, 11);
		} else if (robot_sprite.vy < 0) {
			robot_sprite.texture.frame = new Rectangle( (Math.round(timer * 0.2) % 2) * 8 + 96, 0, 8, 11);
		}

		if (robot_sprite.vx > 0) {
			robot_sprite.texture.frame = new Rectangle( (Math.round(timer * 0.2) % 2) * 8 + 48, 0, 8, 11);
		} else if (robot_sprite.vx < 0) {
			robot_sprite.texture.frame = new Rectangle( (Math.round(timer * 0.2) % 2) * 8 + 80, 0, 8, 11);
		}

		if (robot_sprite.vx === 0 && robot_sprite.vy === 0) {
			robot_sprite.texture.frame = new Rectangle( (Math.round(timer * 0.2) % 6) * 8, 0, 8, 11);
		}
	}
	
}

function gameOver () {
	setup();
}

function hitTestAny () {
	var was_hit = hitTestRectangle(player_sprite, robot_sprite);

	for (var i = 0, len = walls.length; i < len; i++) {
		was_hit = was_hit || hitTestRectangle(player_sprite, walls[i]);
	}

	return was_hit;
}
function keyboard (code) {

	var key = {
		code: code,
		isDown: false,
		isUp: true,
		press: null,
		release: null
	};

	key.downHandler = function (evt) {

		if (evt.code === key.code) {
			if (key.isUp && key.press) { key.press(); }
			key.isDown = true;
			key.isUp = false;
		}
		evt.preventDefault();
	};

	key.upHandler = function(evt) {
		if (evt.code === key.code) {
			if (key.isDown && key.release) { key.release(); }
			key.isDown = false;
			key.isUp = true;
		}
		evt.preventDefault();
	};

	window.addEventListener("keydown", key.downHandler.bind(key), false);
	window.addEventListener("keyup", key.upHandler.bind(key), false);
	
	return key;
}

function hitTestRectangle(r1, r2) {

	var hit = false;
	var combinedHalfWidths;
	var combinedHalfHeights;
	var vx;
	var vy;
	var fudge_factor = 2;

	//Find the center points of each sprite
	r1.centerX = r1.x + r1.width * 0.5;
	r1.centerY = r1.y + r1.height * 0.5;
	r2.centerX = r2.x + r2.width * 0.5;
	r2.centerY = r2.y + r2.height * 0.5;

	//Find the half-widths and half-heights of each sprite
	r1.halfWidth = r1.width * 0.5 - fudge_factor;
	r1.halfHeight = r1.height * 0.5 - fudge_factor;
	r2.halfWidth = r2.width * 0.5 - fudge_factor;
	r2.halfHeight = r2.height * 0.5 - fudge_factor;

	//Calculate the distance vector between the sprites
	vx = r1.centerX - r2.centerX;
	vy = r1.centerY - r2.centerY;

	//Figure out the combined half-widths and half-heights
	combinedHalfWidths = r1.halfWidth + r2.halfWidth;
	combinedHalfHeights = r1.halfHeight + r2.halfHeight;

	//Check for a collision on the x axis
	if (Math.abs(vx) < combinedHalfWidths) {

		//A collision might be occuring. Check for a collision on the y axis
		if (Math.abs(vy) < combinedHalfHeights) {

			//There's definitely a collision happening
			hit = true;
		} else {

			//There's no collision on the y axis
			hit = false;
		}
	} else {

		//There's no collision on the x axis
		hit = false;
	}

	//`hit` will be either `true` or `false`
	return hit;
};

function setUpPlayerCtrlsFor (sprite) {

	var moveUp = keyboard(sprite.ctrl_keys[0]);
	var moveRight = keyboard(sprite.ctrl_keys[1]);
	var moveDown = keyboard(sprite.ctrl_keys[2]);
	var moveLeft = keyboard(sprite.ctrl_keys[3]);

	moveLeft.press = function () {
		sprite.vx = sprite.rate * -1;
	};

	moveLeft.release = function () {
		if (moveRight.isDown === false) {
			sprite.vx = 0;
		}
	};

	moveRight.press = function () {
		sprite.vx = sprite.rate;
	};

	moveRight.release = function () {
		if (moveLeft.isDown === false) {
			sprite.vx = 0;
		}
	};

	moveUp.press = function () {
		sprite.vy = sprite.rate * -1;
	};

	moveUp.release = function () {
		if (moveDown.isDown === false) {
			sprite.vy = 0;
		}
	};

	moveDown.press = function () {
		sprite.vy = sprite.rate;
	};

	moveDown.release = function () {
		if (moveUp.isDown === false) {
			sprite.vy = 0;
		}
	};
}

function getTexFrameFor (sprite) {

	var rect = new Rectangle(0, 0, 8, 17);

	if (sprite.vx > 0 || sprite.vy !== 0) {
		rect = new Rectangle( (Math.round(timer * 0.2) % 3) * 8 + 8, 0, 8, 17);
	}

	if (sprite.vx < 0) {
		rect = new Rectangle( (Math.round(timer * 0.2) % 3) * 8 + 40, 0, 8, 17);
	}

	return rect;
}

function drawWalls () {
	
	var num_cols = 5;
	var num_rows = 3;
	var box_width = 200;
	var box_height = 235;
	var x_pos = 10;
	var y_pos = 10;
	var rect = null;
	var sides = "top,right,bottom,left".split(',');
	var random_side = '';

	for (var w = 0; w < num_rows; w++) {

		x_pos = 10;

		for (var h = 0; h < num_cols; h++) {
			random_side = sides[Math.floor(Math.random() * sides.length)];
			rect = new Grfx();
			rect.beginFill(0x0000FF);
			rect.lineStyle(1, 0xFF3300, 1); // debug
			switch (random_side) {

				case 'top': 
				rect.drawRect(x_pos, y_pos, box_width + 10, 10);
				rect.x = 0;
				rect.y = 0;
				break;

				case 'right': 
				rect.drawRect(x_pos, y_pos, 10, box_height + 5);
				rect.x = box_width;
				rect.y = 0;
				break;

				case 'bottom': 
				rect.drawRect(x_pos, y_pos, box_width + 5, 10);
				rect.x = 0;
				rect.y = box_height;
				break;

				case 'left': 
				rect.drawRect(x_pos, y_pos, 10, box_height + 5);
				rect.x = 0;
				rect.y = 0;
				break;
			}

			rect.endFill();
			stage.addChild(rect);

			// for hit testing
			walls.push(rect);

			x_pos += box_width;
		}

		y_pos += box_height;
	}
}

function playerDead () {

	timer += 1;

	if (timer - death_start_timer < player_sprite.death_anim_duration) {
		// player death
		player_sprite.texture.frame = new Rectangle((Math.round(timer * 0.4) % 4) * 8 + 80, 0, 8, 17);
		player_sprite.tint = colors8[Math.floor(Math.random() * colors8.length)];
	} else {
		stage.removeChild(player_sprite);
	}

	// robot death
	var frame_num = (Math.round((timer - death_start_timer) * 0.1) % 4);
	
	if (frame_num < robot_sprite.explode_tex.num_frames) {
		robot_sprite.texture = robot_sprite.explode_tex;
		robot_sprite.anchor.x = 0.28;
		robot_sprite.anchor.y = 0.28;
		robot_sprite.texture.frame = new Rectangle( frame_num * 18, 0, 18, 18);
	} else {
		stage.removeChild(robot_sprite);
		// robot_sprite.destroy();
	}
}

</script>
</body>
